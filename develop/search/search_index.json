{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ServeStatic","text":"<p>Production-grade static file server for Python web apps.</p> <p>A fork of WhiteNoise for ASGI support, maintenance, and feature updates.</p> <p>With a couple of lines of configuration <code>ServeStatic</code> allows your web app to serve its own static files, making it a self-contained unit that can be deployed anywhere without relying on nginx, Amazon S3, or any other external service. This is especially useful on Heroku, OpenShift, and other PaaS providers.</p> <p>It's designed to work nicely with a CDN for high-traffic sites so you don't have to sacrifice performance to benefit from simplicity.</p> <p><code>ServeStatic</code> works with any ASGI or WSGI compatible app but has some special auto-configuration features for Django.</p> <p><code>ServeStatic</code> automatically takes care of best-practices for you, for instance:</p> <ul> <li>Serving compressed content (gzip and Brotli formats, handling Accept-Encoding and Vary headers correctly)</li> <li>Setting far-future cache headers on content which won't change</li> </ul> <p>Worried that serving static files with Python is horribly inefficient? Still think you should be using Amazon S3? Have a look at the FAQ below.</p>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"#isnt-serving-static-files-from-python-horribly-inefficient","title":"Isn't serving static files from Python horribly inefficient?","text":"<p>The short answer to this is that if you care about performance and efficiency then you should be using <code>ServeStatic</code> behind a CDN like CloudFront. If you're doing that then, because of the caching headers <code>ServeStatic</code> sends, the vast majority of static requests will be served directly by the CDN without touching your application, so it really doesn't make much difference how efficient <code>ServeStatic</code> is.</p> <p>That said, <code>ServeStatic</code> is pretty efficient. Because it only has to serve a fixed set of files it does all the work of finding files and determining the correct headers upfront on initialization. Requests can then be served with little more than a dictionary lookup to find the appropriate response. Also, when used with gunicorn (and most other WSGI servers) the actual business of pushing the file down the network interface is handled by the kernel's very efficient <code>sendfile</code> syscall, not by Python.</p>"},{"location":"#shouldnt-i-be-pushing-my-static-files-to-s3-using-something-like-django-storages","title":"Shouldn't I be pushing my static files to S3 using something like Django-Storages?","text":"<p>No, you shouldn't. The main problem with this approach is that Amazon S3 cannot currently selectively serve compressed content to your users. Compression (using either the venerable gzip or the more modern brotli algorithms) can make dramatic reductions in the bandwidth required for your CSS and JavaScript. But in order to do this correctly the server needs to examine the <code>Accept-Encoding</code> header of the request to determine which compression formats are supported, and return an appropriate <code>Vary</code> header so that intermediate caches know to do the same. This is exactly what <code>ServeStatic</code> does, but Amazon S3 currently provides no means of doing this.</p> <p>The second problem with a push-based approach to handling static files is that it adds complexity and fragility to your deployment process: extra libraries specific to your storage backend, extra configuration and authentication keys, and extra tasks that must be run at specific points in the deployment in order for everything to work. With the CDN-as-caching-proxy approach that <code>ServeStatic</code> takes there are just two bits of configuration: your application needs the URL of the CDN, and the CDN needs the URL of your application. Everything else is just standard HTTP semantics. This makes your deployments simpler, your life easier, and you happier.</p>"},{"location":"#whats-the-point-in-servestatic-when-i-can-do-the-same-thing-in-a-few-lines-of-apachenginx","title":"What's the point in <code>ServeStatic</code> when I can do the same thing in a few lines of <code>apache</code>/<code>nginx</code>?","text":"<p>There are two answers here. One is that ServeStatic is designed to work in situations where <code>apache</code>, <code>nginx</code>, and the like aren't easily available. But more importantly, it's easy to underestimate what's involved in serving static files correctly. Does your few lines of nginx configuration distinguish between files which might change and files which will never change and set the cache headers appropriately? Did you add the right CORS headers so that your fonts load correctly when served via a CDN? Did you turn on the special nginx setting which allows it to send gzip content in response to an <code>HTTP/1.0</code> request, which for some reason CloudFront still uses? Did you install the extension which allows you to serve brotli-encoded content to modern browsers?</p> <p>None of this is rocket science, but it's fiddly and annoying and <code>ServeStatic</code> takes care of all it for you.</p>"},{"location":"asgi/","title":"Using <code>ServeStatic</code> with ASGI apps","text":"<p>Tip</p> <p><code>ServeStaticASGI</code> inherits its interface and features from the WSGI variant.</p> <p>To enable <code>ServeStatic</code> you need to wrap your existing ASGI application in a <code>ServeStatic</code> instance and tell it where to find your static files. For example:</p> <pre><code>from servestatic import ServeStaticASGI\n\nfrom my_project import MyASGIApp\n\napplication = MyASGIApp()\napplication = ServeStaticASGI(application, root=\"/path/to/static/files\")\napplication.add_files(\"/path/to/more/static/files\", prefix=\"more-files/\")\n</code></pre> <p>On initialization, <code>ServeStatic</code> walks over all the files in the directories that have been added (descending into sub-directories) and builds a list of available static files. Any requests which match a static file get served by <code>ServeStatic</code>, all others are passed through to the original application.</p> <p>See the API reference documentation for detailed usage and features.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Nothing (yet)!</li> </ul>"},{"location":"changelog/#301-2025-03-02","title":"3.0.1 - 2025-03-02","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed compatibility between the two following Django settings: <code>SERVESTATIC_KEEP_ONLY_HASHED_FILES</code> and <code>SERVESTATIC_USE_MANIFEST</code></li> </ul>"},{"location":"changelog/#300-2025-01-10","title":"3.0.0 - 2025-01-10","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Drop Django 3.2 and 4.1 support.</li> <li>Any errors from threads in the <code>servestatic.compress</code> command are now raised.</li> <li>Compression code has been refactored to match upstream (WhiteNoise).</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Add <code>asgiref</code> to dependencies to fix import error.</li> </ul>"},{"location":"changelog/#211-2024-10-27","title":"2.1.1 - 2024-10-27","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Make sure WSGI <code>SlicedFile</code> is closed properly to prevent subtle bugs.</li> </ul>"},{"location":"changelog/#210-2024-10-02","title":"2.1.0 - 2024-10-02","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support Python 3.13.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Query strings are now preserved during HTTP redirection.</li> </ul>"},{"location":"changelog/#201-2024-09-13","title":"2.0.1 - 2024-09-13","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix crash when running <code>manage.py collectstatic</code> when Django's <code>settings.py:STATIC_ROOT</code> is a <code>Path</code> object.</li> </ul>"},{"location":"changelog/#200-2024-09-12","title":"2.0.0 - 2024-09-12","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Django <code>settings.py:SERVESTATIC_USE_MANIFEST</code> will allow ServeStatic to use the Django manifest rather than scanning the filesystem.<ul> <li>When also using ServeStatic's <code>CompressedManifestStaticFilesStorage</code> backend, ServeStatic will no longer need to call <code>os.stat</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Minimum python version is now 3.9.</li> <li>Django <code>setings.py:SERVESTATIC_USE_FINDERS</code> will now discover files strictly using the finders API. Previously, ServeStatic would also scan <code>settings.py:STATIC_ROOT</code> for files not found by the finders API.</li> <li>Async file reading is now done via threads rather than <code>aiofiles</code> due recent performance tests.</li> <li><code>BaseServeStatic</code> has been renamed to <code>ServeStaticBase</code>.</li> <li><code>AsgiFileServer</code> has been renamed to <code>FileServerASGI</code>.</li> <li>Lots of internal refactoring to improve performance, code quality, and maintainability.</li> </ul>"},{"location":"changelog/#120-2024-08-30","title":"1.2.0 - 2024-08-30","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Verbose Django <code>404</code> error page when <code>settings.py:DEBUG</code> is <code>True</code></li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fix Django compatibility with third-party sync middleware.<ul> <li>ServeStatic Django middleware now only runs in async mode to avoid clashing with Django's internal usage of <code>asgiref.AsyncToSync</code>.</li> </ul> </li> <li>Respect Django <code>settings.py:FORCE_SCRIPT_NAME</code> configuration value.</li> </ul>"},{"location":"changelog/#110-2024-08-27","title":"1.1.0 - 2024-08-27","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Files are now compressed within a thread pool to increase performance.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fix Django <code>StreamingHttpResponse must consume synchronous iterators</code> warning.</li> <li>Fix Django bug where file paths could fail to be followed on Windows.</li> </ul>"},{"location":"changelog/#100-2024-05-08","title":"1.0.0 - 2024-05-08","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Forked from <code>whitenoise</code> to add ASGI support.</li> </ul>"},{"location":"contributing/","title":"Contributor Guide","text":""},{"location":"contributing/#creating-a-development-environment","title":"Creating a development environment","text":"<p>If you plan to make code changes to this repository, you will need to install the following dependencies first:</p> <ul> <li>Git</li> <li>Python 3.9+</li> <li>Hatch</li> </ul> <p>Once you finish installing these dependencies, you can clone this repository:</p> <pre><code>git clone https://github.com/Archmonger/ServeStatic.git\ncd ServeStatic\n</code></pre>"},{"location":"contributing/#executing-test-environment-commands","title":"Executing test environment commands","text":"<p>By utilizing <code>hatch</code>, the following commands are available to manage the development environment.</p>"},{"location":"contributing/#tests","title":"Tests","text":"Command Description <code>hatch test</code> Run Python tests using the current environment's Python version <code>hatch test --all</code> Run tests using all compatible Python and Django versions <code>hatch test --python 3.9</code> Run tests using a specific Python version <code>hatch test --include \"django=5.1\"</code> Run tests using a specific Django version <code>hatch test -k test_get_js_static_file</code> Run only a specific test What other arguments are available to me? <p>The <code>hatch test</code> command is a wrapper for <code>pytest</code>. Hatch \"intercepts\" a handful of arguments, which can be previewed by typing <code>hatch test --help</code>.</p> <p>Any additional arguments in the <code>test</code> command are directly passed on to pytest. See the pytest documentation for what additional arguments are available.</p>"},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"Command Description <code>hatch fmt</code> Run all linters and formatters <code>hatch fmt --check</code> Run all linters and formatters, but do not save fixes to the disk <code>hatch fmt --linter</code> Run only linters <code>hatch fmt --formatter</code> Run only formatters <code>hatch run precommit:check</code> Run all <code>pre-commit</code> checks configured within this repository <code>hatch run precommit:update</code> Update the <code>pre-commit</code> hooks configured within this repository Configure your IDE for linting <p>This repository uses <code>hatch fmt</code> for linting and formatting, which is a modestly customized version of <code>ruff</code>.</p> <p>You can install <code>ruff</code> as a plugin to your preferred code editor to create a similar environment.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"Command Description <code>hatch run docs:serve</code> Start the <code>mkdocs</code> server to view documentation locally <code>hatch run docs:build</code> Build the documentation <code>hatch run docs:linkcheck</code> Check for broken links in the documentation <code>hatch run scripts\\validate_changelog.py</code> Check if the changelog meets the Keep A Changelog specification"},{"location":"contributing/#environment-management","title":"Environment Management","text":"Command Description <code>hatch build --clean</code> Build the package from source <code>hatch env prune</code> Delete all virtual environments created by <code>hatch</code> <code>hatch python install 3.12</code> Install a specific Python version to your system Check out Hatch for all available commands! <p>This documentation only covers commonly used commands.</p> <p>You can type <code>hatch --help</code> to see all available commands.</p>"},{"location":"django-faq/","title":"FAQ","text":""},{"location":"django-faq/#how-to-i-use-servestatic-with-django-compressor","title":"How to I use <code>ServeStatic</code> with Django Compressor?","text":"<p>For performance and security reasons <code>ServeStatic</code> does not check for new files after startup (unless using Django DEBUG mode). As such, all static files must be generated in advance. If you're using Django Compressor, this can be performed using its offline compression feature.</p>"},{"location":"django-faq/#can-i-use-servestatic-for-media-files","title":"Can I use <code>ServeStatic</code> for media files?","text":"<p><code>ServeStatic</code> is not suitable for serving user-uploaded \"media\" files. For one thing, as described above, it only checks for static files at startup and so files added after the app starts won't be seen. More importantly though, serving user-uploaded files from the same domain as your main application is a security risk (this blog post from Google security describes the problem well). And in addition to that, using local disk to store and serve your user media makes it harder to scale your application across multiple machines.</p> <p>For all these reasons, it's much better to store files on a separate dedicated storage service and serve them to users from there. The django-storages library provides many options e.g. Amazon S3, Azure Storage, and Rackspace CloudFiles.</p>"},{"location":"django-faq/#how-check-if-servestatic-is-working","title":"How check if <code>ServeStatic</code> is working?","text":"<p>You can confirm that <code>ServeStatic</code> is installed and configured correctly by running you application locally with <code>DEBUG</code> disabled and checking that your static files still load.</p> <p>First you need to run <code>collectstatic</code> to get your files in the right place:</p> <pre><code>python manage.py collectstatic\n</code></pre> <p>Then make sure <code>DEBUG</code> is set to <code>False</code> in your <code>settings.py</code> and start the server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>You should find that your static files are served, just as they would be in production.</p>"},{"location":"django-faq/#how-do-i-troubleshoot-the-servestatic-storage-backend","title":"How do I troubleshoot the <code>ServeStatic</code> storage backend?","text":"<p>If you're having problems with the <code>ServeStatic</code> storage backend, the chances are they're due to the underlying Django storage engine. This is because <code>ServeStatic</code> only adds a thin wrapper around Django's storage to add compression support, and because the compression code is very simple it generally doesn't cause problems.</p> <p>The most common issue is that there are CSS files which reference other files (usually images or fonts) which don't exist at that specified path. When Django attempts to rewrite these references it looks for the corresponding file and throws an error if it can't find it.</p> <p>To test whether the problems are due to <code>ServeStatic</code> or not, try swapping the <code>ServeStatic</code> storage backend for the Django one:</p> <pre><code>STORAGES = {\n    \"staticfiles\": {\n        \"BACKEND\": \"django.contrib.staticfiles.storage.ManifestStaticFilesStorage\",\n    },\n}\n</code></pre> <p>If the problems persist then your issue is with Django itself (try the docs or the mailing list). If the problem only occurs with ServeStatic then raise a ticket on the issue tracker.</p>"},{"location":"django-faq/#can-i-use-servestatic-with-other-storage-backends","title":"Can I use <code>ServeStatic</code> with other storage backends?","text":"<p><code>ServeStatic</code> will only work with storage backends that stores their files on the local filesystem in <code>STATIC_ROOT</code>. It will not work with backends that store files remotely, for instance on Amazon S3.</p>"},{"location":"django-faq/#why-does-servestatic-make-my-tests-run-slow","title":"Why does <code>ServeStatic</code> make my tests run slow?","text":"<p><code>ServeStatic</code> is designed to do as much work as possible upfront when the application starts so that it can serve files as efficiently as possible while the application is running. This makes sense for long-running production processes, but you might find that the added startup time is a problem during test runs when application instances are frequently being created and destroyed.</p> <p>The simplest way to fix this is to make sure that during testing the <code>SERVESTATIC_AUTOREFRESH</code> setting is set to <code>True</code>. (By default it is <code>True</code> when <code>DEBUG</code> is enabled and <code>False</code> otherwise.) This stops <code>ServeStatic</code> from scanning your static files on start up but other than that its behaviour should be exactly the same.</p> <p>It is also worth making sure you don't have unnecessary files in your <code>STATIC_ROOT</code> directory. In particular, be careful not to include a <code>node_modules</code> directory which can contain a very large number of files and significantly slow down your application startup. If you need to include specific files from <code>node_modules</code> then you can create symlinks from within your static directory to just the files you need.</p>"},{"location":"django-faq/#why-do-i-get-valueerror-missing-staticfiles-manifest-entry-for","title":"Why do I get \"ValueError: Missing staticfiles manifest entry for ...\"?","text":"<p>If you are seeing this error that means you are referencing a static file in your templates using something like <code>{% static \"foo\" %}</code> which doesn't exist, or at least isn't where Django expects it to be. If you don't understand why Django can't find the file you can use</p> <pre><code>python manage.py findstatic --verbosity 2 foo\n</code></pre> <p>which will show you all the paths which Django searches for the file \"foo\".</p> <p>If, for some reason, you want Django to silently ignore such errors you can set <code>SERVESTATIC_MANIFEST_STRICT</code> to <code>False</code>.</p>"},{"location":"django-faq/#how-do-i-use-servestatic-with-webpackbrowserifyetc","title":"How do I use <code>ServeStatic</code> with Webpack/Browserify/etc?","text":"<p>A simple technique for integrating any frontend build system with Django is to use a directory layout like this:</p> <pre><code>./static_src\n        \u2193\n  $ ./node_modules/.bin/webpack\n        \u2193\n./static_build\n        \u2193\n  $ ./manage.py collectstatic\n        \u2193\n./static_root\n</code></pre> <p>Here <code>static_src</code> contains all the source files (JS, CSS, etc) for your project. Your build tool (which can be Webpack, Browserify or whatever you choose) then processes these files and writes the output into <code>static_build</code>.</p> <p>The path to the <code>static_build</code> directory is added to <code>settings.py</code>:</p> <pre><code>STATICFILES_DIRS = [BASE_DIR / \"static_build\"]\n</code></pre> <p>This means that Django can find the processed files, but doesn't need to know anything about the tool which produced them.</p> <p>The final <code>manage.py collectstatic</code> step writes \"hash-versioned\" and compressed copies of the static files into <code>static_root</code> ready for production.</p> <p>Note, both the <code>static_build</code> and <code>static_root</code> directories should be excluded from version control (e.g. through <code>.gitignore</code>) and only the <code>static_src</code> directory should be checked in.</p>"},{"location":"django-faq/#how-do-i-deploy-an-application-which-is-not-at-the-root-of-the-domain","title":"How do I deploy an application which is not at the root of the domain?","text":"<p>Sometimes Django apps are deployed at a particular prefix (or \"subdirectory\") on a domain e.g. <code>https://example.com/my-app/</code> rather than just <code>https://example.com</code>.</p> <p>In this case you would normally use Django's FORCE_SCRIPT_NAME setting to tell the application where it is located. You would also need to ensure that <code>STATIC_URL</code> uses the correct prefix as well. For example:</p> <pre><code>FORCE_SCRIPT_NAME = \"/my-app\"\nSTATIC_URL = FORCE_SCRIPT_NAME + \"/static/\"\n</code></pre> <p>If you have set these two values then <code>ServeStatic</code> will automatically configure itself correctly. If you are doing something more complex you may need to set <code>SERVESTATIC_STATIC_PREFIX</code> explicitly yourself.</p>"},{"location":"django-settings/","title":"Settings","text":"<p>Note</p> <p>The <code>ServeStaticMiddleware</code> class can take the same configuration options as the <code>ServeStatic</code> base class, but rather than accepting keyword arguments to its constructor it uses Django settings. The setting names are just the keyword arguments upper-cased with a <code>SERVESTATIC_</code> prefix.</p>"},{"location":"django-settings/#servestatic_root","title":"<code>SERVESTATIC_ROOT</code>","text":"<p>Default: <code>None</code></p> <p>Absolute path to a directory of files which will be served at the root of your application (ignored if not set).</p> <p>Don't use this for the bulk of your static files because you won't benefit from cache versioning, but it can be convenient for files like <code>robots.txt</code> or <code>favicon.ico</code> which you want to serve at a specific URL.</p>"},{"location":"django-settings/#servestatic_autorefresh","title":"<code>SERVESTATIC_AUTOREFRESH</code>","text":"<p>Default: <code>settings.py:DEBUG</code></p> <p>Recheck the filesystem to see if any files have changed before responding. This is designed to be used in development where it can be convenient to pick up changes to static files without restarting the server. For both performance and security reasons, this setting should not be used in production.</p>"},{"location":"django-settings/#servestatic_use_manifest","title":"<code>SERVESTATIC_USE_MANIFEST</code>","text":"<p>Default: <code>not settings.py:DEBUG and isinstance(staticfiles_storage, ManifestStaticFilesStorage)</code></p> <p>Find and serve files using Django's manifest file.</p> <p>This is the most efficient way to determine what files are available, but it requires that you are using a manifest-compatible storage backend.</p> <p>When using ServeStatic's <code>CompressedManifestStaticFilesStorage</code> storage backend, ServeStatic will no longer need to call <code>os.stat</code> on each file during startup.</p>"},{"location":"django-settings/#servestatic_use_finders","title":"<code>SERVESTATIC_USE_FINDERS</code>","text":"<p>Default: <code>settings.py:DEBUG</code></p> <p>Find and serve files using Django's <code>finders</code> API.</p> <p>It's possible to use this setting in production, but be mindful of the <code>settings.py:STATICFILES_DIRS</code> and <code>settings.py:STATICFILE_FINDERS</code> settings. By default, the finders API only searches the <code>'static'</code> directory in each app, which are not the copies post-processed by ServeStatic.</p> <p>Note that <code>STATICFILES_DIRS</code> cannot equal <code>STATIC_ROOT</code> while running the <code>collectstatic</code> management command.</p>"},{"location":"django-settings/#servestatic_max_age","title":"<code>SERVESTATIC_MAX_AGE</code>","text":"<p>Default: <code>60 if not settings.py:DEBUG else 0</code></p> <p>Time (in seconds) for which browsers and proxies should cache non-versioned files.</p> <p>Versioned files (i.e. files which have been given a unique name like <code>base.a4ef2389.css</code> by including a hash of their contents in the name) are detected automatically and set to be cached forever.</p> <p>The default is chosen to be short enough not to cause problems with stale versions but long enough that, if you're running <code>ServeStatic</code> behind a CDN, the CDN will still take the majority of the strain during times of heavy load.</p> <p>Set to <code>None</code> to disable setting any <code>Cache-Control</code> header on non-versioned files.</p>"},{"location":"django-settings/#servestatic_index_file","title":"<code>SERVESTATIC_INDEX_FILE</code>","text":"<p>Default: <code>False</code></p> <p>If <code>True</code> enable index file serving. If set to a non-empty string, enable index files and use that string as the index file name.</p>"},{"location":"django-settings/#servestatic_mimetypes","title":"<code>SERVESTATIC_MIMETYPES</code>","text":"<p>Default: <code>None</code></p> <p>A dictionary mapping file extensions (lowercase) to the mimetype for that extension. For example: :</p> <pre><code>{ \".foo\": \"application/x-foo\" }\n</code></pre> <p>Note that <code>ServeStatic</code> ships with its own default set of mimetypes and does not use the system-supplied ones (e.g. <code>/etc/mime.types</code>). This ensures that it behaves consistently regardless of the environment in which it's run. View the defaults in ServeStatic's <code>media_types.py</code> file.</p> <p>In addition to file extensions, mimetypes can be specified by supplying the entire filename, for example: :</p> <pre><code>{ \"some-special-file\": \"application/x-custom-type\" }\n</code></pre>"},{"location":"django-settings/#servestatic_charset","title":"<code>SERVESTATIC_CHARSET</code>","text":"<p>Default: <code>'utf-8'</code></p> <p>Charset to add as part of the <code>Content-Type</code> header for all files whose mimetype allows a charset.</p>"},{"location":"django-settings/#servestatic_allow_all_origins","title":"<code>SERVESTATIC_ALLOW_ALL_ORIGINS</code>","text":"<p>Default: <code>True</code></p> <p>Toggles whether to send an <code>Access-Control-Allow-Origin: *</code> header for all static files.</p> <p>This allows cross-origin requests for static files which means your static files will continue to work as expected even if they are served via a CDN and therefore on a different domain. Without this your static files will mostly work, but you may have problems with fonts loading in Firefox, or accessing images in canvas elements, or other mysterious things.</p> <p>The W3C explicitly state that this behaviour is safe for publicly accessible files.</p>"},{"location":"django-settings/#servestatic_skip_compress_extensions","title":"<code>SERVESTATIC_SKIP_COMPRESS_EXTENSIONS</code>","text":"<p>Default: <code>('jpg', 'jpeg', 'png', 'gif', 'webp','zip', 'gz', 'tgz', 'bz2', 'tbz', 'xz', 'br', 'swf', 'flv', 'woff', 'woff2')</code></p> <p>File extensions to skip when compressing.</p> <p>Because the compression process will only create compressed files where this results in an actual size saving, it would be safe to leave this list empty and attempt to compress all files. However, for files which we're confident won't benefit from compression, it speeds up the process if we just skip over them.</p>"},{"location":"django-settings/#servestatic_add_headers_function","title":"<code>SERVESTATIC_ADD_HEADERS_FUNCTION</code>","text":"<p>Default: <code>None</code></p> <p>Reference to a function which is passed the headers object for each static file, allowing it to modify them.</p> <p>The function should not return anything; changes should be made by modifying the headers dictionary directly.</p> <p>For example:</p> <pre><code>def force_download_pdfs(headers, path, url):\n    \"\"\"\n    Args:\n        headers: A [wsgiref.headers](https://docs.python.org/3/library/wsgiref.html#module-wsgiref.headers)\\\n            instance (which you can treat just as a dict) containing the headers for the current file\n        path: The absolute path to the local file\n        url: The host-relative URL of the file e.g. `/static/styles/app.css`\n\n    \"\"\"\n    if path.endswith(\".pdf\"):\n        headers[\"Content-Disposition\"] = \"attachment\"\n\n\nSERVESTATIC_ADD_HEADERS_FUNCTION = force_download_pdfs\n</code></pre>"},{"location":"django-settings/#servestatic_immutable_file_test","title":"<code>SERVESTATIC_IMMUTABLE_FILE_TEST</code>","text":"<p>Default: See <code>immutable_file_test</code> in source</p> <p>Reference to function, or string.</p> <p>If a reference to a function, this is passed the path and URL for each static file and should return whether that file is immutable, i.e. guaranteed not to change, and so can be safely cached forever. The default is designed to work with Django's <code>ManifestStaticFilesStorage</code> backend, and any derivatives of that, so you should only need to change this if you are using a different system for versioning your static files.</p> <p>If a string, this is treated as a regular expression and each file's URL is matched against it.</p> <p>Example:</p> <pre><code>def immutable_file_test(path, url):\n    \"\"\"\n    Args:\n        path: The absolute path to the local file\n        url: The host-relative URL of the file e.g. `/static/styles/app.css`\n    \"\"\"\n    # Match filename with 12 hex digits before the extension\n    # e.g. app.db8f2edc0c8a.js\n    return re.match(r\"^.+\\.[0-9a-f]{12}\\..+$\", url)\n\n\nSERVESTATIC_IMMUTABLE_FILE_TEST = immutable_file_test\n</code></pre>"},{"location":"django-settings/#servestatic_static_prefix","title":"<code>SERVESTATIC_STATIC_PREFIX</code>","text":"<p>Default: <code>settings.py:STATIC_URL</code></p> <p>The URL prefix under which static files will be served.</p> <p>If this setting is unset, this value will automatically determined by analysing your <code>STATIC_URL</code> setting. For example, if <code>STATIC_URL = 'https://example.com/static/'</code> then <code>SERVESTATIC_STATIC_PREFIX</code> will be <code>/static/</code>.</p> <p>Note that <code>FORCE_SCRIPT_NAME</code> is also taken into account when automatically determining this value. For example, if <code>FORCE_SCRIPT_NAME = 'subdir/'</code> and <code>STATIC_URL = 'subdir/static/'</code> then <code>SERVESTATIC_STATIC_PREFIX</code> will be <code>/static/</code>.</p> <p>If your deployment is more complicated than this (for instance, if you are using a CDN which is doing path rewriting) then you may need to configure this value directly.</p>"},{"location":"django-settings/#servestatic_keep_only_hashed_files","title":"<code>SERVESTATIC_KEEP_ONLY_HASHED_FILES</code>","text":"<p>Default: <code>False</code></p> <p>Stores only files with hashed names in <code>STATIC_ROOT</code>.</p> <p>By default, Django's hashed static files system creates two copies of each file in <code>STATIC_ROOT</code>: one using the original name, e.g. <code>app.js</code>, and one using the hashed name, e.g. <code>app.db8f2edc0c8a.js</code>. If <code>ServeStatic</code>'s compression backend is being used this will create another two copies of each of these files (using Gzip and Brotli compression) resulting in six output files for each input file.</p> <p>In some deployment scenarios it can be important to reduce the size of the build artifact as much as possible. This setting removes the \"unhashed\" version of the file (which should be not be referenced in any case) which should reduce the space required for static files by half.</p> <p>This setting is only effective if the <code>ServeStatic</code> storage backend is being used.</p>"},{"location":"django-settings/#servestatic_manifest_strict","title":"<code>SERVESTATIC_MANIFEST_STRICT</code>","text":"<p>Default: <code>True</code></p> <p>Set to <code>False</code> to prevent Django throwing an error if you reference a static file which doesn't exist in the manifest.</p> <p>This works by setting the <code>manifest_strict</code> option on the underlying Django storage instance, as described in the Django documentation.</p> <p>This setting is only effective if the <code>ServeStatic</code> storage backend is being used.</p> <p>Note</p> <p>If a file isn't found in the <code>staticfiles.json</code> manifest at runtime, a <code>ValueError</code> is raised. This behavior can be disabled by subclassing <code>ManifestStaticFilesStorage</code> and setting the <code>manifest_strict</code> attribute to <code>False</code> -- nonexistent paths will remain unchanged.</p>"},{"location":"django/","title":"Using <code>ServeStatic</code> with Django","text":"<p>This guide walks you through setting up a Django project with ServeStatic. In most cases it shouldn't take more than a couple of lines of configuration.</p> <p>We mention Heroku in a few places, but there's nothing Heroku-specific about ServeStatic and the instructions below should apply whatever your hosting platform.</p>"},{"location":"django/#step-1-enable-servestatic","title":"Step 1: Enable ServeStatic","text":"<p>Edit your <code>settings.py</code> file and add ServeStatic to the <code>MIDDLEWARE</code> list.</p> <p>Middleware order is important!</p> <p>The ServeStatic middleware should be placed directly after the Django SecurityMiddleware (if you are using it) and before all other middleware.</p> <pre><code>MIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"servestatic.middleware.ServeStaticMiddleware\",\n    # ...\n]\n</code></pre> <p>That's it! ServeStatic is now configured to serve your static files. For optimal performance, proceed to the next step to enable compression and caching.</p> How should I order my middleware? <p>You might find other third-party middleware that suggests it should be given highest priority at the top of the middleware list. Unless you understand exactly what is happening you should ignore this advice and always place <code>ServeStaticMiddleware</code> above other middleware.</p>"},{"location":"django/#step-2-add-compression-and-caching-support","title":"Step 2: Add compression and caching support","text":"<p>ServeStatic comes with a storage backend which compresses your files and hashes them to unique names, so they can safely be cached forever. To use it, set it as your staticfiles storage backend in your settings file.</p> <pre><code>STORAGES = {\n    # ...\n    \"staticfiles\": {\n        \"BACKEND\": \"servestatic.storage.CompressedManifestStaticFilesStorage\",\n    },\n}\n</code></pre> <p>This combines automatic compression with the caching behaviour provided by Django's ManifestStaticFilesStorage backend. If you want to apply compression but don't want the caching behaviour then you can use the alternative backend:</p> <pre><code>\"servestatic.storage.CompressedStaticFilesStorage\"\n</code></pre> <p>If you need to compress files outside of the static files storage system you can use the supplied command line utility.</p> Enable Brotli compression <p>As well as the common gzip compression format, ServeStatic supports the newer, more efficient brotli format. This helps reduce bandwidth and increase loading speed. To enable brotli compression you will need the Brotli Python package installed by running <code>pip install servestatic[brotli]</code>.</p> <p>Brotli is supported by all major browsers (except IE11). ServeStatic will only serve brotli data to browsers which request it so there are no compatibility issues with enabling brotli support.</p> <p>Also note that browsers will only request brotli data over an HTTPS connection.</p>"},{"location":"django/#step-3-make-sure-djangos-staticfiles-is-configured-correctly","title":"Step 3: Make sure Django's <code>staticfiles</code> is configured correctly","text":"<p>If you're familiar with Django you'll know what to do. If you're just getting started with a new Django project then you'll need add the following to the bottom of your <code>settings.py</code> file:</p> <pre><code>STATIC_ROOT = BASE_DIR / \"staticfiles\"\n</code></pre> <p>As part of deploying your application you'll need to run <code>./manage.py collectstatic</code> to put all your static files into <code>STATIC_ROOT</code>. (If you're running on Heroku then this is done automatically for you.)</p> <p>Make sure you're using the static template tag to refer to your static files, rather than writing the URL directly. For example:</p> <pre><code>{% load static %}\n&lt;img src=\"{% static \"images/hi.jpg\" %}\" alt=\"Hi!\"&gt;\n\n&lt;!-- DON'T WRITE THIS --&gt;\n&lt;img src=\"/static/images/hi.jpg\" alt=\"Hi!\"&gt;\n</code></pre> <p>For further details see the Django staticfiles guide.</p>"},{"location":"django/#optional-steps","title":"Optional Steps","text":""},{"location":"django/#configure-servestatic","title":"Configure ServeStatic","text":"<p>ServeStatic has a number of configuration options that you can set in your <code>settings.py</code> file.</p> <p>See the reference documentation for a full list of options.</p>"},{"location":"django/#utilize-a-content-delivery-network-cdn","title":"Utilize a Content Delivery Network (CDN)","text":"<p>The above steps will get you decent performance on moderate traffic sites, however for higher traffic sites, or sites where performance is a concern you should look at using a CDN.</p> <p>Because ServeStatic sends appropriate cache headers with your static content, the CDN will be able to cache your files and serve them without needing to contact your application again.</p> <p>Below are instruction for setting up ServeStatic with Amazon CloudFront, a popular choice of CDN. The process for other CDNs should look very similar though.</p> Configuring Amazon CloudFront <p>Go to CloudFront section of the AWS Web Console, and click \"Create Distribution\". Put your application's domain (without the <code>http</code> prefix) in the \"Origin Domain Name\" field and leave the rest of the settings as they are.</p> <p>It might take a few minutes for your distribution to become active. Once it's ready, copy the distribution domain name into your <code>settings.py</code> file so it looks something like this:</p> <pre><code>STATIC_HOST = \"https://d4663kmspf1sqa.cloudfront.net\" if not DEBUG else \"\"\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>Or, even better, you can avoid hard-coding your CDN into your settings by doing something like this:</p> <pre><code>STATIC_HOST = os.environ.get(\"DJANGO_STATIC_HOST\", \"\")\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>This way you can configure your CDN just by setting an environment variable. For apps on Heroku, you'd run this command</p> <pre><code>heroku config:set DJANGO_STATIC_HOST=https://d4663kmspf1sqa.cloudfront.net\n</code></pre> CloudFront compression algorithms <p>By default, CloudFront will discard any <code>Accept-Encoding</code> header browsers include in requests, unless the value of the header is gzip. If it is gzip, CloudFront will fetch the uncompressed file from the origin, compress it, and return it to the requesting browser.</p> <p>To get CloudFront to not do the compression itself as well as serve files compressed using other algorithms, such as Brotli, you must configure your distribution to cache based on the Accept-Encoding header. You can do this in the <code>Behaviours</code> tab of your distribution.</p> CloudFront SEO issues <p>The instructions for setting up CloudFront given above will result in the entire site being accessible via the CloudFront URL. It's possible that this can cause SEO problems if these URLs start showing up in search results. You can restrict CloudFront to only proxy your static files by following these directions:</p> <ol> <li>Go to your newly created distribution and click \"Distribution Settings\", then the \"Behaviors\" tab, then \"Create Behavior\". Put <code>static/*</code> into the path pattern and click \"Create\" to save.</li> <li>Now select the <code>Default (*)</code> behaviour and click \"Edit\". Set \"Restrict Viewer Access\" to \"Yes\" and then click \"Yes, Edit\" to save.</li> <li>Check that the <code>static/*</code> pattern is first on the list, and the default one is second. This will ensure that requests for static files are passed through but all others are blocked.</li> </ol>"},{"location":"django/#enable-servestatic-during-development","title":"Enable ServeStatic during development","text":"<p>In development Django's <code>runserver</code> automatically takes over static file handling. In most cases this is fine, however this means that some of the improvements that ServeStatic makes to static file handling won't be available in development and it opens up the possibility for differences in behaviour between development and production environments. For this reason it's a good idea to use ServeStatic in development as well.</p> <p>You can disable Django's static file handling and allow ServeStatic to take over simply by passing the <code>--nostatic</code> option to the <code>runserver</code> command, but you need to remember to add this option every time you call <code>runserver</code>. An easier way is to edit your <code>settings.py</code> file and add <code>servestatic.runserver_nostatic</code> to the top of your <code>INSTALLED_APPS</code> list:</p> <pre><code>INSTALLED_APPS = [\n    \"servestatic.runserver_nostatic\",\n    \"django.contrib.staticfiles\",\n    # ...\n]\n</code></pre>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2024 Mark Bakhit</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>The documentation below is a quick-start guide to using <code>ServeStatic</code> to serve your static files. For more detailed information see the full installation docs.</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>Install with:</p> <pre><code>pip install servestatic\n</code></pre>"},{"location":"quick-start/#using-with-django","title":"Using with Django","text":"<p>Edit your <code>settings.py</code> file and add <code>ServeStatic</code> to the <code>MIDDLEWARE</code> list, above all other middleware apart from Django's SecurityMiddleware.</p> <pre><code>MIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"servestatic.middleware.ServeStaticMiddleware\",\n    # ...\n]\n</code></pre> <p>That's it, you're ready to go.</p> <p>Want forever-cacheable files and compression support? Just add this to your <code>settings.py</code>.</p> <pre><code>STORAGES = {\n    \"staticfiles\": {\n        \"BACKEND\": \"servestatic.storage.CompressedManifestStaticFilesStorage\",\n    },\n}\n</code></pre> <p>For more details, including on setting up CloudFront and other CDNs see the full Django guide.</p>"},{"location":"quick-start/#using-with-wsgi","title":"Using with WSGI","text":"<p>To enable <code>ServeStatic</code> you need to wrap your existing WSGI application in a <code>ServeStatic</code> instance and tell it where to find your static files. For example...</p> <pre><code>from servestatic import ServeStatic\n\nfrom my_project import MyWSGIApp\n\napplication = MyWSGIApp()\napplication = ServeStatic(application, root=\"/path/to/static/files\")\napplication.add_files(\"/path/to/more/static/files\", prefix=\"more-files/\")\n</code></pre> <p>And that's it, you're ready to go. For more details see the full WSGI guide.</p>"},{"location":"quick-start/#using-with-asgi","title":"Using with ASGI","text":"<p>To enable <code>ServeStatic</code> you need to wrap your existing ASGI application in a <code>ServeStatic</code> instance and tell it where to find your static files. For example...</p> <pre><code>from servestatic import ServeStaticASGI\n\nfrom my_project import MyASGIApp\n\napplication = MyASGIApp()\napplication = ServeStaticASGI(application, root=\"/path/to/static/files\")\napplication.add_files(\"/path/to/more/static/files\", prefix=\"more-files/\")\n</code></pre> <p>And that's it, you're ready to go. For more details see the full ASGI guide.</p>"},{"location":"servestatic-asgi/","title":"<code>ServeStaticASGI</code> API Reference","text":"<p>Tip</p> <p><code>ServeStaticASGI</code> inherits its interface and features from the WSGI variant.</p> Name Type Description Default <code>application</code> <code>Callable</code> Original ASGI application N/A <code>root</code> <code>str</code> Absolute path to a directory of static files to be served. <code>None</code> <code>prefix</code> <code>str</code> If set, the URL prefix under which the files will be served. Trailing slashes are automatically added. <code>None</code> <code>**kwargs</code> Sets configuration attributes for this instance N/A"},{"location":"servestatic-asgi/#configuration-attributes","title":"Configuration attributes","text":"<p>These can be set by passing keyword arguments to the constructor, or by sub-classing ServeStatic and setting the attributes directly.</p>"},{"location":"servestatic-asgi/#autorefresh","title":"<code>autorefresh</code>","text":"<p>Default: <code>False</code></p> <p>Recheck the filesystem to see if any files have changed before responding. This is designed to be used in development where it can be convenient to pick up changes to static files without restarting the server. For both performance and security reasons, this setting should not be used in production.</p>"},{"location":"servestatic-asgi/#max_age","title":"<code>max_age</code>","text":"<p>Default: <code>60</code></p> <p>Time (in seconds) for which browsers and proxies should cache files.</p> <p>The default is chosen to be short enough not to cause problems with stale versions but long enough that, if you're running ServeStatic behind a CDN, the CDN will still take the majority of the strain during times of heavy load.</p> <p>Set to <code>None</code> to disable setting any <code>Cache-Control</code> header on non-versioned files.</p>"},{"location":"servestatic-asgi/#index_file","title":"<code>index_file</code>","text":"<p>Default: <code>False</code></p> <p>If <code>True</code> enable index file serving. If set to a non-empty string, enable index files and use that string as the index file name.</p> <p>When the <code>index_file</code> option is enabled:</p> <ul> <li>Visiting <code>/example/</code> will serve the file at <code>/example/index.html</code></li> <li>Visiting <code>/example</code> will redirect (302) to <code>/example/</code></li> <li>Visiting <code>/example/index.html</code> will redirect (302) to <code>/example/</code></li> </ul> <p>If you want to something other than <code>index.html</code> as the index file, then you can also set this option to an alternative filename.</p>"},{"location":"servestatic-asgi/#mimetypes","title":"<code>mimetypes</code>","text":"<p>Default: <code>None</code></p> <p>A dictionary mapping file extensions (lowercase) to the mimetype for that extension. For example:</p> <pre><code>{\".foo\": \"application/x-foo\"}\n</code></pre> <p>Note that ServeStatic ships with its own default set of mimetypes and does not use the system-supplied ones (e.g. <code>/etc/mime.types</code>). This ensures that it behaves consistently regardless of the environment in which it's run. View the defaults in the <code>media_types.py</code> file.</p> <p>In addition to file extensions, mimetypes can be specified by supplying the entire filename, for example:</p> <pre><code>{ \"some-special-file\": \"application/x-custom-type\" }\n</code></pre>"},{"location":"servestatic-asgi/#charset","title":"<code>charset</code>","text":"<p>Default: <code>utf-8</code></p> <p>Charset to add as part of the <code>Content-Type</code> header for all files whose mimetype allows a charset.</p>"},{"location":"servestatic-asgi/#allow_all_origins","title":"<code>allow_all_origins</code>","text":"<p>Default: <code>True</code></p> <p>Toggles whether to send an <code>Access-Control-Allow-Origin: *</code> header for all static files.</p> <p>This allows cross-origin requests for static files which means your static files will continue to work as expected even if they are served via a CDN and therefore on a different domain. Without this your static files will mostly work, but you may have problems with fonts loading in Firefox, or accessing images in canvas elements, or other mysterious things.</p> <p>The W3C explicitly state that this behaviour is safe for publicly accessible files.</p>"},{"location":"servestatic-asgi/#add_headers_function","title":"<code>add_headers_function</code>","text":"<p>Default: <code>None</code></p> <p>Reference to a function which is passed the headers object for each static file, allowing it to modify them.</p> <p>For example...</p> <pre><code>def force_download_pdfs(headers, path, url):\n    \"\"\"\n    Args:\n        headers: A wsgiref.headers instance (which you can treat \\\n            just as a dict) containing the headers for the current \\\n            file\n        path: The absolute path to the local file\n        url: The host-relative URL of the file e.g. \\\n            `/static/styles/app.css`\n\n    Returns:\n        None. Changes should be made by modifying the headers \\\n        dictionary directly.\n    \"\"\"\n    if path.endswith(\".pdf\"):\n        headers[\"Content-Disposition\"] = \"attachment\"\n\n\napplication = ServeStatic(\n    application,\n    add_headers_function=force_download_pdfs,\n)\n</code></pre>"},{"location":"servestatic-asgi/#immutable_file_test","title":"<code>immutable_file_test</code>","text":"<p>Default: <code>return False</code></p> <p>Reference to function, or string.</p> <p>If a reference to a function, this is passed the path and URL for each static file and should return whether that file is immutable, i.e. guaranteed not to change, and so can be safely cached forever.</p> <p>If a string, this is treated as a regular expression and each file's URL is matched against it.</p> <p>For example...</p> <pre><code>def immutable_file_test(path, url):\n    \"\"\"\n    Args:\n        path: The absolute path to the local file.\n        url: The host-relative URL of the file e.g. \\\n            `/static/styles/app.css`\n\n    Returns:\n        bool. Whether the file is immutable.\n\n    \"\"\"\n    # Match filename with 12 hex digits before the extension\n    # e.g. app.db8f2edc0c8a.js\n    return re.match(r\"^.+\\.[0-9a-f]{12}\\..+$\", url)\n</code></pre>"},{"location":"servestatic-asgi/#compression-support","title":"Compression Support","text":"<p>When ServeStatic builds its list of available files it checks for corresponding files with a <code>.gz</code> and a <code>.br</code> suffix (e.g., <code>scripts/app.js</code>, <code>scripts/app.js.gz</code> and <code>scripts/app.js.br</code>). If it finds them, it will assume that they are (respectively) gzip and brotli compressed versions of the original file and it will serve them in preference to the uncompressed version where clients indicate that they that compression format (see note on Amazon S3 for why this behaviour is important).</p> <p>ServeStatic comes with a command line utility which will generate compressed versions of your files for you. Note that in order for brotli compression to work the Brotli Python package must be installed.</p> <p>Usage is simple:</p> <pre><code>$ python -m servestatic.compress --help\nusage: compress.py [-h] [-q] [--no-gzip] [--no-brotli]\n                   root [extensions [extensions ...]]\n\nSearch for all files inside &lt;root&gt; *not* matching &lt;extensions&gt; and produce\ncompressed versions with '.gz' and '.br' suffixes (as long as this results in\na smaller file)\n\npositional arguments:\n  root         Path root from which to search for files\n  extensions   File extensions to exclude from compression (default: jpg,\n               jpeg, png, gif, webp, zip, gz, tgz, bz2, tbz, xz, br, swf, flv,\n               woff, woff2)\n\noptional arguments:\n  -h, --help   show this help message and exit\n  -q, --quiet  Don't produce log output\n  --no-gzip    Don't produce gzip '.gz' files\n  --no-brotli  Don't produce brotli '.br' files\n</code></pre> <p>You can either run this during development and commit your compressed files to your repository, or you can run this as part of your build and deploy processes. (Note that this is handled automatically in Django if you're using the custom storage backend.)</p>"},{"location":"servestatic-asgi/#caching-headers","title":"Caching Headers","text":"<p>By default, ServeStatic sets a max-age header on all responses it sends. You can configure this by passing a <code>max_age</code> keyword argument.</p> <p>ServeStatic sets both <code>Last-Modified</code> and <code>ETag</code> headers for all files and will return Not Modified responses where appropriate. The ETag header uses the same format as nginx which is based on the size and last-modified time of the file. If you want to use a different scheme for generating ETags you can set them via you own function by using the <code>add_headers_function</code> option.</p> <p>Most modern static asset build systems create uniquely named versions of each file. This results in files which are immutable (i.e., they can never change their contents) and can therefore by cached indefinitely. In order to take advantage of this, ServeStatic needs to know which files are immutable. This can be done using the <code>immutable_file_test</code> option which accepts a reference to a function.</p> <p>The exact details of how you implement this method will depend on your particular asset build system but see the documentation documentation for a simple example.</p> <p>Once you have implemented this, any files which are flagged as immutable will have \"cache forever\" headers set.</p>"},{"location":"servestatic-asgi/#using-a-content-distribution-network","title":"Using a Content Distribution Network","text":"<p>The above steps will get you decent performance on moderate traffic sites, however for higher traffic sites, or sites where performance is a concern you should look at using a CDN.</p> <p>Because ServeStatic sends appropriate cache headers with your static content, the CDN will be able to cache your files and serve them without needing to contact your application again.</p> <p>Below are instruction for setting up ServeStatic with Amazon CloudFront, a popular choice of CDN. The process for other CDNs should look very similar though.</p> Configuring Amazon CloudFront <p>Go to CloudFront section of the AWS Web Console, and click \"Create Distribution\". Put your application's domain (without the <code>http</code> prefix) in the \"Origin Domain Name\" field and leave the rest of the settings as they are.</p> <p>It might take a few minutes for your distribution to become active. Once it's ready, copy the distribution domain name into your <code>settings.py</code> file so it looks something like this:</p> <pre><code>STATIC_HOST = \"https://d4663kmspf1sqa.cloudfront.net\" if not DEBUG else \"\"\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>Or, even better, you can avoid hard-coding your CDN into your settings by doing something like this:</p> <pre><code>STATIC_HOST = os.environ.get(\"DJANGO_STATIC_HOST\", \"\")\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>This way you can configure your CDN just by setting an environment variable. For apps on Heroku, you'd run this command</p> <pre><code>heroku config:set DJANGO_STATIC_HOST=https://d4663kmspf1sqa.cloudfront.net\n</code></pre> CloudFront compression algorithms <p>By default, CloudFront will discard any <code>Accept-Encoding</code> header browsers include in requests, unless the value of the header is gzip. If it is gzip, CloudFront will fetch the uncompressed file from the origin, compress it, and return it to the requesting browser.</p> <p>To get CloudFront to not do the compression itself as well as serve files compressed using other algorithms, such as Brotli, you must configure your distribution to cache based on the Accept-Encoding header. You can do this in the <code>Behaviours</code> tab of your distribution.</p> CloudFront SEO issues <p>The instructions for setting up CloudFront given above will result in the entire site being accessible via the CloudFront URL. It's possible that this can cause SEO problems if these URLs start showing up in search results. You can restrict CloudFront to only proxy your static files by following these directions:</p> <ol> <li>Go to your newly created distribution and click \"Distribution Settings\", then the \"Behaviors\" tab, then \"Create Behavior\". Put <code>static/*</code> into the path pattern and click \"Create\" to save.</li> <li>Now select the <code>Default (*)</code> behaviour and click \"Edit\". Set \"Restrict Viewer Access\" to \"Yes\" and then click \"Yes, Edit\" to save.</li> <li>Check that the <code>static/*</code> pattern is first on the list, and the default one is second. This will ensure that requests for static files are passed through but all others are blocked.</li> </ol>"},{"location":"servestatic/","title":"<code>ServeStatic</code> API Reference","text":"Name Type Description Default <code>application</code> <code>Callable</code> Original WSGI application N/A <code>root</code> <code>str</code> Absolute path to a directory of static files to be served. <code>None</code> <code>prefix</code> <code>str</code> If set, the URL prefix under which the files will be served. Trailing slashes are automatically added. <code>None</code> <code>**kwargs</code> Sets configuration attributes for this instance N/A"},{"location":"servestatic/#configuration-attributes","title":"Configuration attributes","text":"<p>These can be set by passing keyword arguments to the constructor, or by sub-classing ServeStatic and setting the attributes directly.</p>"},{"location":"servestatic/#autorefresh","title":"<code>autorefresh</code>","text":"<p>Default: <code>False</code></p> <p>Recheck the filesystem to see if any files have changed before responding. This is designed to be used in development where it can be convenient to pick up changes to static files without restarting the server. For both performance and security reasons, this setting should not be used in production.</p>"},{"location":"servestatic/#max_age","title":"<code>max_age</code>","text":"<p>Default: <code>60</code></p> <p>Time (in seconds) for which browsers and proxies should cache files.</p> <p>The default is chosen to be short enough not to cause problems with stale versions but long enough that, if you're running ServeStatic behind a CDN, the CDN will still take the majority of the strain during times of heavy load.</p> <p>Set to <code>None</code> to disable setting any <code>Cache-Control</code> header on non-versioned files.</p>"},{"location":"servestatic/#index_file","title":"<code>index_file</code>","text":"<p>Default: <code>False</code></p> <p>If <code>True</code> enable index file serving. If set to a non-empty string, enable index files and use that string as the index file name.</p> <p>When the <code>index_file</code> option is enabled:</p> <ul> <li>Visiting <code>/example/</code> will serve the file at <code>/example/index.html</code></li> <li>Visiting <code>/example</code> will redirect (302) to <code>/example/</code></li> <li>Visiting <code>/example/index.html</code> will redirect (302) to <code>/example/</code></li> </ul> <p>If you want to something other than <code>index.html</code> as the index file, then you can also set this option to an alternative filename.</p>"},{"location":"servestatic/#mimetypes","title":"<code>mimetypes</code>","text":"<p>Default: <code>None</code></p> <p>A dictionary mapping file extensions (lowercase) to the mimetype for that extension. For example:</p> <pre><code>{\".foo\": \"application/x-foo\"}\n</code></pre> <p>Note that ServeStatic ships with its own default set of mimetypes and does not use the system-supplied ones (e.g. <code>/etc/mime.types</code>). This ensures that it behaves consistently regardless of the environment in which it's run. View the defaults in the <code>media_types.py</code> file.</p> <p>In addition to file extensions, mimetypes can be specified by supplying the entire filename, for example:</p> <pre><code>{ \"some-special-file\": \"application/x-custom-type\" }\n</code></pre>"},{"location":"servestatic/#charset","title":"<code>charset</code>","text":"<p>Default: <code>utf-8</code></p> <p>Charset to add as part of the <code>Content-Type</code> header for all files whose mimetype allows a charset.</p>"},{"location":"servestatic/#allow_all_origins","title":"<code>allow_all_origins</code>","text":"<p>Default: <code>True</code></p> <p>Toggles whether to send an <code>Access-Control-Allow-Origin: *</code> header for all static files.</p> <p>This allows cross-origin requests for static files which means your static files will continue to work as expected even if they are served via a CDN and therefore on a different domain. Without this your static files will mostly work, but you may have problems with fonts loading in Firefox, or accessing images in canvas elements, or other mysterious things.</p> <p>The W3C explicitly state that this behaviour is safe for publicly accessible files.</p>"},{"location":"servestatic/#add_headers_function","title":"<code>add_headers_function</code>","text":"<p>Default: <code>None</code></p> <p>Reference to a function which is passed the headers object for each static file, allowing it to modify them.</p> <p>For example...</p> <pre><code>def force_download_pdfs(headers, path, url):\n    \"\"\"\n    Args:\n        headers: A wsgiref.headers instance (which you can treat \\\n            just as a dict) containing the headers for the current \\\n            file\n        path: The absolute path to the local file\n        url: The host-relative URL of the file e.g. \\\n            `/static/styles/app.css`\n\n    Returns:\n        None. Changes should be made by modifying the headers \\\n        dictionary directly.\n    \"\"\"\n    if path.endswith(\".pdf\"):\n        headers[\"Content-Disposition\"] = \"attachment\"\n\n\napplication = ServeStatic(\n    application,\n    add_headers_function=force_download_pdfs,\n)\n</code></pre>"},{"location":"servestatic/#immutable_file_test","title":"<code>immutable_file_test</code>","text":"<p>Default: <code>return False</code></p> <p>Reference to function, or string.</p> <p>If a reference to a function, this is passed the path and URL for each static file and should return whether that file is immutable, i.e. guaranteed not to change, and so can be safely cached forever.</p> <p>If a string, this is treated as a regular expression and each file's URL is matched against it.</p> <p>For example...</p> <pre><code>def immutable_file_test(path, url):\n    \"\"\"\n    Args:\n        path: The absolute path to the local file.\n        url: The host-relative URL of the file e.g. \\\n            `/static/styles/app.css`\n\n    Returns:\n        bool. Whether the file is immutable.\n\n    \"\"\"\n    # Match filename with 12 hex digits before the extension\n    # e.g. app.db8f2edc0c8a.js\n    return re.match(r\"^.+\\.[0-9a-f]{12}\\..+$\", url)\n</code></pre>"},{"location":"servestatic/#compression-support","title":"Compression Support","text":"<p>When ServeStatic builds its list of available files it checks for corresponding files with a <code>.gz</code> and a <code>.br</code> suffix (e.g., <code>scripts/app.js</code>, <code>scripts/app.js.gz</code> and <code>scripts/app.js.br</code>). If it finds them, it will assume that they are (respectively) gzip and brotli compressed versions of the original file and it will serve them in preference to the uncompressed version where clients indicate that they that compression format (see note on Amazon S3 for why this behaviour is important).</p> <p>ServeStatic comes with a command line utility which will generate compressed versions of your files for you. Note that in order for brotli compression to work the Brotli Python package must be installed.</p> <p>Usage is simple:</p> <pre><code>$ python -m servestatic.compress --help\nusage: compress.py [-h] [-q] [--no-gzip] [--no-brotli]\n                   root [extensions [extensions ...]]\n\nSearch for all files inside &lt;root&gt; *not* matching &lt;extensions&gt; and produce\ncompressed versions with '.gz' and '.br' suffixes (as long as this results in\na smaller file)\n\npositional arguments:\n  root         Path root from which to search for files\n  extensions   File extensions to exclude from compression (default: jpg,\n               jpeg, png, gif, webp, zip, gz, tgz, bz2, tbz, xz, br, swf, flv,\n               woff, woff2)\n\noptional arguments:\n  -h, --help   show this help message and exit\n  -q, --quiet  Don't produce log output\n  --no-gzip    Don't produce gzip '.gz' files\n  --no-brotli  Don't produce brotli '.br' files\n</code></pre> <p>You can either run this during development and commit your compressed files to your repository, or you can run this as part of your build and deploy processes. (Note that this is handled automatically in Django if you're using the custom storage backend.)</p>"},{"location":"servestatic/#caching-headers","title":"Caching Headers","text":"<p>By default, ServeStatic sets a max-age header on all responses it sends. You can configure this by passing a <code>max_age</code> keyword argument.</p> <p>ServeStatic sets both <code>Last-Modified</code> and <code>ETag</code> headers for all files and will return Not Modified responses where appropriate. The ETag header uses the same format as nginx which is based on the size and last-modified time of the file. If you want to use a different scheme for generating ETags you can set them via you own function by using the <code>add_headers_function</code> option.</p> <p>Most modern static asset build systems create uniquely named versions of each file. This results in files which are immutable (i.e., they can never change their contents) and can therefore by cached indefinitely. In order to take advantage of this, ServeStatic needs to know which files are immutable. This can be done using the <code>immutable_file_test</code> option which accepts a reference to a function.</p> <p>The exact details of how you implement this method will depend on your particular asset build system but see the documentation documentation for a simple example.</p> <p>Once you have implemented this, any files which are flagged as immutable will have \"cache forever\" headers set.</p>"},{"location":"servestatic/#using-a-content-distribution-network","title":"Using a Content Distribution Network","text":"<p>The above steps will get you decent performance on moderate traffic sites, however for higher traffic sites, or sites where performance is a concern you should look at using a CDN.</p> <p>Because ServeStatic sends appropriate cache headers with your static content, the CDN will be able to cache your files and serve them without needing to contact your application again.</p> <p>Below are instruction for setting up ServeStatic with Amazon CloudFront, a popular choice of CDN. The process for other CDNs should look very similar though.</p> Configuring Amazon CloudFront <p>Go to CloudFront section of the AWS Web Console, and click \"Create Distribution\". Put your application's domain (without the <code>http</code> prefix) in the \"Origin Domain Name\" field and leave the rest of the settings as they are.</p> <p>It might take a few minutes for your distribution to become active. Once it's ready, copy the distribution domain name into your <code>settings.py</code> file so it looks something like this:</p> <pre><code>STATIC_HOST = \"https://d4663kmspf1sqa.cloudfront.net\" if not DEBUG else \"\"\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>Or, even better, you can avoid hard-coding your CDN into your settings by doing something like this:</p> <pre><code>STATIC_HOST = os.environ.get(\"DJANGO_STATIC_HOST\", \"\")\nSTATIC_URL = STATIC_HOST + \"/static/\"\n</code></pre> <p>This way you can configure your CDN just by setting an environment variable. For apps on Heroku, you'd run this command</p> <pre><code>heroku config:set DJANGO_STATIC_HOST=https://d4663kmspf1sqa.cloudfront.net\n</code></pre> CloudFront compression algorithms <p>By default, CloudFront will discard any <code>Accept-Encoding</code> header browsers include in requests, unless the value of the header is gzip. If it is gzip, CloudFront will fetch the uncompressed file from the origin, compress it, and return it to the requesting browser.</p> <p>To get CloudFront to not do the compression itself as well as serve files compressed using other algorithms, such as Brotli, you must configure your distribution to cache based on the Accept-Encoding header. You can do this in the <code>Behaviours</code> tab of your distribution.</p> CloudFront SEO issues <p>The instructions for setting up CloudFront given above will result in the entire site being accessible via the CloudFront URL. It's possible that this can cause SEO problems if these URLs start showing up in search results. You can restrict CloudFront to only proxy your static files by following these directions:</p> <ol> <li>Go to your newly created distribution and click \"Distribution Settings\", then the \"Behaviors\" tab, then \"Create Behavior\". Put <code>static/*</code> into the path pattern and click \"Create\" to save.</li> <li>Now select the <code>Default (*)</code> behaviour and click \"Edit\". Set \"Restrict Viewer Access\" to \"Yes\" and then click \"Yes, Edit\" to save.</li> <li>Check that the <code>static/*</code> pattern is first on the list, and the default one is second. This will ensure that requests for static files are passed through but all others are blocked.</li> </ol>"},{"location":"wsgi/","title":"Using <code>ServeStatic</code> with WSGI apps","text":"<p>To enable <code>ServeStatic</code> you need to wrap your existing WSGI application in a <code>ServeStatic</code> instance and tell it where to find your static files. For example:</p> <pre><code>from servestatic import ServeStatic\n\nfrom my_project import MyWSGIApp\n\napplication = MyWSGIApp()\napplication = ServeStatic(application, root=\"/path/to/static/files\")\napplication.add_files(\"/path/to/more/static/files\", prefix=\"more-files/\")\n</code></pre> <p>On initialization, <code>ServeStatic</code> walks over all the files in the directories that have been added (descending into sub-directories) and builds a list of available static files. Any requests which match a static file get served by <code>ServeStatic</code>, all others are passed through to the original application.</p> <p>See the API reference documentation for detailed usage and features.</p>"}]}